h1. Overview

We currently don't have a standard way of integrating with IT/OPs in respect to application-level monitoring. The following is a proposal for standardizing on how we monitor applications (specifically Java apps) both in [Amazon cloud|http://go/cloud] and our data center. This has already been implemented and many applications currently use it (e.g. {{evcache}}, {{discovery}}, {{rheventsconsumer}}, etc.)

h1. Goals

* *JMX-based*  — since it's the standard for Java applications and lots of existing tools already integrate with JMX
* *simple*  — we shouldn't have to write lots of code (e.g. writing {{XMBean}} interfaces and implementing them)
* *easy to register new monitors*  — should be dynamically driven (e.g. no need to file CMCs and have to wait for SAs to set up new monitors)
* *integrated with IT/OPs monitoring strategy/solution* :
** collect data for trending ([Epic|http://go/epic] & [Appdynamics|null:AppDynamics]) as well as alerting ([Nimsoft|http://go/nms] & [Appdynamics|null:AppDynamics])
** provide application developers a way to specify the graph type for trending purposes
** provide application developers a way to specify min/max thresholds for alerting purposes (Note: This is not currently supported by our alerting backend systems yet)

h1. Approach

* use annotations as to set monitors (along with thresholds)
* use {{RDDTool}} semantics (for trending data) — open-source standard, high-performance data logging and graphing system for time-series data; IT/Ops currently uses this already in [Epic|http://go/epic]
* all monitors will be available as MBeans uner a well-known domain name: {{com.netflix.MonitoredResources:\*}}. Monitoring/alerting systems will use JMX to query this data:
*EPIC*
when you integrate {{epic-plugin.jar}} into your application, the {{epic-plugin}} library will dynamically find resources to monitor and push them to the appropriate destination (cloud: {{epicproxy}} nodes; DC: directly to {{epicapi.netflix.com}})
*AppDynamics*  (cloud only)
we have a plug-in to the machineagent framework which will use JMX similar to the epic-plugin to push datapoints to the AppDynamics controller. This plug-in is part of the base AMI so Java applications running in [the cloud|http://go/cloud] get this for free. In addition to monitoring/trending, you can set up alerts on AppDynamics on any of these datapoints
*Nimsoft*  (alerting only)
for [Nimsoft|http://go/nms], you currently have to [file a helpdesk ticket|http://helpdesk.netflix.com/ticket/create_ticket.php] and assign it to the OSD group. You'll need to specify the ObjectName of the mbean and thresholds for alerting.

h2. Definitions / Conventions
* *DataSourceName*
** name of the monitor (e.g. datapoint name)
* *DataSourceType*
** type of monitor; the following are the currently supported types:
{code:java}
/**
 * Defines rdd data source types that are supported by EPIC.
 *
 * @author gkim
 */
public enum DataSourceType {
    /**
     * GAUGE does not save the rate of change. The value measured at a point
     * in time is stored. Examples are: CPU, memory, and disk usage
     */
    GAUGE,

    /**
     * COUNTER will save the rate of change of the value over a step period.
     * This assumes that the value is always increasing (the difference between
     * the current and the previous value is greater than 0).
     */
    COUNTER,

    /**
     * DERIVE is the same as COUNTER, but it allows negative values as well.
     */
    DERIVE,

    /**
     * Not part of RRD DST, but useful for status (Up/Down) monitoring
     */
    BOOLEAN,

    /**
     * Not part of RRD DST, but useful for debugging. This will not be monitoring
     * by the NOC.
     */
    INFORMATIONAL;
}
{code}

* [{{platform.jar}}|http://go/platform.jar] creates the JMX {{ObjectName}} using the following rule:__
** com.netflix.MonitoredResources:type=\[PLATFORM_|PDCLOUDMIG:_ APPLICATION\],name=_classname_ \[PDCLOUDMIG:,instance=_mon-id_ \]

* {{type}} is either "{{PLATFORM}}" (for [{{platform.jar}}|http://go/platform.jar] components) or "{{APPLICATION}}" (all others)
* _classname_  = _XXX_ .class.getSimpleName( ) of the target class
* _mon-id_ =value of field annotated with @MonitorId
* [{{platform.jar}}|http://go/platform.jar] adds {{instance}} only if it finds {{@MonitorId}} in the class (this is a way to differentiate multiple instances of the same class)

* uses Open MBean — MBean where the types of attributes and of operation parameters and return values are basic, predefined Java classes. This facilitates operation with remote management programs that do not necessarily have access to application-specific types.
** doc: [http://download.oracle.com/javase/6/docs/api/index.html?javax/management/openmbean/package-summary.html]

h2. Steps for Setting up Monitors on Your Code

# If you are running in [the cloud|http://go/cloud] you'll need to remove *-Dcom.sun.management.jmxremote* and *-Dcom.sun.management.jmxremote.port=7500* from _setenv.sh_, otherwise you won't be able to connect to the JMX port from outside [EC2|http://go/ec2]. An explanation of why is documented in the Appendix below.
# Annotate with _@Monitor_ at the method or field level and optionally annotate with _@MonitorId_ if you'd like to dynamically further qualify by instance otherwise, we will override conflicting registrations with the same _dataSourceName_. Example:{code:java}// The name of the resource pool.
@MonitorId
private String _poolName = null;

@Monitor(dataSourceName="NumOfInvalidResources",type=DataSourceType.GAUGE)
private volatile int _numOfInvalidResources;
…

@Monitor(dataSourceName="NumOfAvailableResources", type=DataSourceType.GAUGE)
public int getObjectsAvailable() { return _availableResourcePool.size(); }

@Monitor(dataSourceName="NumOfInUseResources", type=DataSourceType.GAUGE)
public int getObjectsInUse() { return (_borrowedResourcesTable!=null ?_borrowedResourcesTable.size():0); }

@Monitor(dataSourceName="MachineStatus", type=DataSourceType.BOOLEAN, expectedValue="UP")
private Status status = Status.UP;{code}
# *Register with the* {{*MonitorRegistry* }}*. Example:* {code}public ResourceX() {
 …
 //This is all you need to do in order to register your object
 MonitorRegistry.getInstance().registerObject(this);
 …
}

public void shutdown() {
 …
 //Best practice to cleanup here
 MonitorRegistry.getInstance().unRegisterObject(this);
 …
}{code}
# *That's it.*

* How it'll look on JConsole:
!jconsole-1.png!

h3. Valid characters for DataSourceName and MonitorId

These are the allowed characters that you can have in the DataSourceName and MonitorIds.

* *alphanumeric*  \[PDCLOUDMIG:{{A}}–{{Za}}–{{z0}}–{{9}}\]
* *underscore*  '{{_}}'
* *hyphen*  '{{-}}'
* *period*  '{{.}}'

h1. Integration with Monitoring/Alerting Systems

h2. CloudWatch
h3. Setting up alerts in CloudWatch


h1. Appendix

h2. 1. JMX in the Cloud

We're currently using 7500 as the RMI registry port, but since the RMI transport layer opens dynamic socket connections between the client and the server to facilitate communication this doesn't work in [the Amazon cloud|http://go/cloud] since ports are all blocked by default.

* *Note* : If you're running on [the Amazon cloud|http://go/cloud], a workaround is in [{{platform.jar}}|http://go/cloud] to fix the port at 7500 (same as RMI registry port) to export the remote objects on. Also since [the Amazon cloud|http://go/cloud] uses a NAT device for resolving external IP addresses, we also automatically set the {{java.rmi.server.hostname}} as well.
* So for [the Amazon cloud|http://go/cloud] — we'll need to remove {{?Dcom.sun.management.jmxremote ?Dcom.sun.management.jmxremote.port=7500}} from {{setenv.sh}}.

h2. 2. Sample Code for Querying JMX for the Curious

Quick and dirty code snippet to dynamically get a list of what to monitor:
{code}public class JMXClientTest {
    public static void main(String[] args) {

        try{
            if(args.length <  2) {
                System.out.println("Usage: java JMXClientTest <host> <port>");
                System.exit(1);
            }
            String host = args[0];
            String port = args[1];

            System.out.println("All currently registered MonitoredResources:");

            String jmxURL = "service:jmx:rmi://"+host + ":" + port +"/jndi/rmi://" + host + ":" + port + "/jmxrmi";

            MBeanServerConnection connection = JMXConnectorFactory.connect(new JMXServiceURL(jmxURL),
                    null).getMBeanServerConnection();

            ObjectName pattern = new ObjectName("com.netflix.MonitoredResources:*");
            Set<ObjectName> objNames = connection.queryNames(pattern, null);

            for(ObjectName objName : objNames) {

                System.out.println("\tObjectName: " + objName.toString());

                MBeanAttributeInfo[] attrs = connection.getMBeanInfo(objName).getAttributes();
                if(attrs != null) {
                    String attrStrings[] = new String[attrs.length];
                    for (int i = 0; i < attrStrings.length; i++) {
                        attrStrings[i] = attrs[i].getName();
                    }
                    AttributeList list = connection.getAttributes(objName, attrStrings);

                    for(Attribute a : list.asList() ) {
                        System.out.println("\t\t" + a.getName() + ": ");
                        if(a.getValue() instanceof CompositeDataSupport) {
                            CompositeDataSupport compositeData =(CompositeDataSupport) a.getValue();
                            CompositeType compositeType = compositeData.getCompositeType();
                            for(Object key : compositeType.keySet()){
                                System.out.println("\t\t\t" + key + " => " + compositeData.get((String)key));
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}{code}
