h1. Overview

Our goal is to provide and simple and easy, standard interface for publishing and monitoring application metrics in Java.  Both in "Amazon":http://aws.amazon.com, other clouds and private data centers. This has already been implemented inside of Netflix and most of our applications currently use it.

h1. Goals

* *Leverage JMX*  — since it's the standard for Java applications and lots of existing tools already integrate with JMX
* *Keep it simple*  — we shouldn't have to write lots of code (e.g. writing XMBean interfaces and implementing them)
* *Make it easy to add new monitors*  — should be dynamically driven (e.g. no need for tickets and operational intervention)
* *Integrated common monitoring solutions* :
** Provide application developers a way to specify the graph type for trending purposes
** Provide application developers a way to specify min/max thresholds for alerting purposes (Note: This is not currently supported by our alerting backend systems yet)

h1. Approach

* Use "Annotations":https://github.com/Netflix/servo/wiki/Annotations to set monitors (and other meta data)
* Use "RDDTool":http://oss.oetiker.ch/rrdtool semantics (for trending data) — open-source standard, high-performance data logging and graphing system for time-series data.
* All monitors will be available as MBeans under a well-known domain name: {{com.netflix.MonitoredResources:\*}}.
* Monitoring/alerting systems will use JMX to query this data.

h2. Definitions / Conventions
* *DataSourceName*
** name of the monitor (e.g. datapoint name)
* *DataSourceType*
** type of monitor; the following are the currently supported types:

"Code":https://github.com/Netflix/servo/blob/master/servo-core/src/main/java/com/netflix/servo/annotations/DataSourceType.java
<pre>
<code>
/**
 * Data source types that are supported.
 *
 * @author gkim
 */
public enum DataSourceType {
    /**
     * GAUGE does not save the rate of change. The value measured at a point
     * in time is stored. Examples are: CPU, memory, and disk usage
     */
    GAUGE,

    /**
     * COUNTER will save the rate of change of the value over a step period.
     * This assumes that the value is always increasing (the difference between
     * the current and the previous value is greater than 0).
     */
    COUNTER,

    /**
     * Not part of RRD DST, but useful for debugging. This will not be monitoring
     * by the NOC.
     */
    INFORMATIONAL;
}
</code>
</pre>

* The JMX {{ObjectName}} using the following rule:__
** com.netflix.MonitoredResources:type=\[PLATFORM_|PDCLOUDMIG:_ APPLICATION\],name=_classname_ \[PDCLOUDMIG:,instance=_mon-id_ \]

* _classname_  = _XXX_ .class.getSimpleName( ) of the target class
* _mon-id_ =value of field annotated with @MonitorId
* Adds {{instance}} only if it finds {{@MonitorId}} in the class (this is a way to differentiate multiple instances of the same class)

* uses Open MBean — MBean where the types of attributes and of operation parameters and return values are basic, predefined Java classes. This facilitates operation with remote management programs that do not necessarily have access to application-specific types.
** doc: [http://download.oracle.com/javase/6/docs/api/index.html?javax/management/openmbean/package-summary.html]

h2. Steps for Setting up Monitors on Your Code

# If you are running in [the cloud|http://go/cloud] you'll need to remove *-Dcom.sun.management.jmxremote* and *-Dcom.sun.management.jmxremote.port=7500* from _setenv.sh_, otherwise you won't be able to connect to the JMX port from outside EC2. An explanation of why is documented in the Appendix below.
# Annotate with _@Monitor_ at the method or field level and optionally annotate with _@MonitorId_ if you'd like to dynamically further qualify by instance otherwise, we will override conflicting registrations with the same _dataSourceName_. Example:

<pre>
<code>
// The name of the resource pool.
@MonitorId
private String _poolName = null;

@Monitor(dataSourceName="NumOfInvalidResources",type=DataSourceType.GAUGE)
private volatile int _numOfInvalidResources;
…

@Monitor(dataSourceName="NumOfAvailableResources", type=DataSourceType.GAUGE)
public int getObjectsAvailable() { return _availableResourcePool.size(); }

@Monitor(dataSourceName="NumOfInUseResources", type=DataSourceType.GAUGE)
public int getObjectsInUse() { return (_borrowedResourcesTable!=null ?_borrowedResourcesTable.size():0); }

@Monitor(dataSourceName="MachineStatus", type=DataSourceType.BOOLEAN, expectedValue="UP")
private Status status = Status.UP;{code}
# *Register with the* {{*MonitorRegistry* }}*. Example:* {code}public ResourceX() {
 …
 //This is all you need to do in order to register your object
 MonitorRegistry.getInstance().registerObject(this);
 …
}

public void shutdown() {
 …
 //Best practice to cleanup here
 MonitorRegistry.getInstance().unRegisterObject(this);
 …
}
</code>
</pre>

# *That's it.*

* How it'll look on JConsole:
ScreenShot Needed

h3. Valid characters for DataSourceName and MonitorId

These are the allowed characters that you can have in the DataSourceName and MonitorIds.

* *alphanumeric* :{{A}}–{{Za}}–{{z0}}–{{9}}\]
* *underscore*  '{{_}}'
* *hyphen*  '{{-}}'
* *period*  '{{.}}'

h1. Integration with Monitoring/Alerting Systems

h2. CloudWatch
h3. Setting up alerts in CloudWatch


h1. Appendix

h2. JMX in the Cloud

We're currently using 7500 as the RMI registry port, but since the RMI transport layer opens dynamic socket connections between the client and the server to facilitate communication this doesn't work in [the Amazon cloud|http://go/cloud] since ports are all blocked by default.

* *Note* : If you're running on [the Amazon cloud|http://go/cloud], a workaround is in [{{platform.jar}}|http://go/cloud] to fix the port at 7500 (same as RMI registry port) to export the remote objects on. Also since [the Amazon cloud|http://go/cloud] uses a NAT device for resolving external IP addresses, we also automatically set the {{java.rmi.server.hostname}} as well.
* So for [the Amazon cloud|http://go/cloud] — we'll need to remove {{?Dcom.sun.management.jmxremote ?Dcom.sun.management.jmxremote.port=7500}} from {{setenv.sh}}.

h2. Sample Code for Querying JMX for the Curious

Quick and dirty code snippet to dynamically get a list of what to monitor:

<pre>
<code>
public class JMXClientTest {
    public static void main(String[] args) {

        try{
            if(args.length <  2) {
                System.out.println("Usage: java JMXClientTest <host> <port>");
                System.exit(1);
            }
            String host = args[0];
            String port = args[1];

            System.out.println("All currently registered MonitoredResources:");

            String jmxURL = "service:jmx:rmi://"+host + ":" + port +"/jndi/rmi://" + host + ":" + port + "/jmxrmi";

            MBeanServerConnection connection = JMXConnectorFactory.connect(new JMXServiceURL(jmxURL),
                    null).getMBeanServerConnection();

            ObjectName pattern = new ObjectName("com.netflix.MonitoredResources:*");
            Set<ObjectName> objNames = connection.queryNames(pattern, null);

            for(ObjectName objName : objNames) {

                System.out.println("\tObjectName: " + objName.toString());

                MBeanAttributeInfo[] attrs = connection.getMBeanInfo(objName).getAttributes();
                if(attrs != null) {
                    String attrStrings[] = new String[attrs.length];
                    for (int i = 0; i < attrStrings.length; i++) {
                        attrStrings[i] = attrs[i].getName();
                    }
                    AttributeList list = connection.getAttributes(objName, attrStrings);

                    for(Attribute a : list.asList() ) {
                        System.out.println("\t\t" + a.getName() + ": ");
                        if(a.getValue() instanceof CompositeDataSupport) {
                            CompositeDataSupport compositeData =(CompositeDataSupport) a.getValue();
                            CompositeType compositeType = compositeData.getCompositeType();
                            for(Object key : compositeType.keySet()){
                                System.out.println("\t\t\t" + key + " => " + compositeData.get((String)key));
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code>
</pre>